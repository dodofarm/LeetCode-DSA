General:
  you most likely don't need to do every operation on every step (e.g. calculate avg) you can do it ONCE at the end. If you need to for exmaple compare averages just compare the max values and caclulate the avg at the end
  when optimizing at the end, think about how to move out the logic that checks only one small thing out of the while/for loop and just have a simple if condition at the end
  sometimes you add unnecessary variables that aren't actually needed, take a look if you really need them or if you can optimize them away.
  maybe replace while loops with for, sometimes that's just better and easier most likely this would apply where you use one or two pointers.
  write out the start and result of an example this might help you get the answer!
Sliding window:
  you might need to fill up the window first!
  if the window size is constant, simply have 1 pointer that's the end of the window and do end of window - size the of the window = beginning of window. Now just use a for loop instead of a while loop.
  for a window where both the start and end just moved you don't need to REDO whatever you do that happens on a window move, you need to ONLY REMOVE the previous value that left the window and ADD the last values that came into the window.
  sometimes you need to not only remove and add 1 values from the beginning and end but progress the beginning and end at different speeds where by stepping with each pointer some condition is checked (e.g. some hashtable, see problem 2)

Quicksort/Quickselect:
  always pay attention to use the actual value in the array in calculations instead of the index

Bucket Sort:
  useful for finding highest (or kth highest frequency in array)

Pointers:
  Generally you will use a while loop to progress the pointers. When you do that it's not the same as with a sliding window where it needs to be filled up first. In the loop do the calculation first and THEN progress one pointer or the other (if you use 2 pointers).

Linked List:
  need THREE pointers to reverse it
  VERY often a dummy node is good! You can use it as a placeholder when you build a list to the retun dummy.next (e.g. problem 2)

Stack:
  think about the ORDER of how items get placed on the stack. Also think about how you can store items temporary where the order should stay the same (see 150)

Recursion:
  Build from the bottom up, instea of passing down a parameter to the lower functions, this is much simpler. E.g. the last call stack return 1, the one before 2 etc. It would look like `return this_funciton() + 1`
  https://www.perplexity.ai/search/def-maxdepth-node-treenode-ans-8OlebG6VTg2M292p36Ywmg

  when using a recursive algorithm like DFS, try to make the basecase 0/None, and don't check for things like `if node.left` this only clutters the code and has no benefit really since the if check is the same as just returning immediately at the top of the recursive function `e.g. if node is none:`.

Multithreading & Multiprocessingin Python:
  python in itself is not multithreaded due to something called global interpreter lock. The interpreter will wait for one task to finish before working on other tasks. To use multithreading you can import `threading`.  
  in python 1 process can only execute 1 thread at a time, they are concurrent but NOT parallel
  
  some extension modules, either standard or third-party, are designed so as to release the GIL when doing computationally-intensive tasks such as compression or hashing. Also, the GIL is always released when doing I/O.
  very good video on multiprocessing vs multiprocessing in python: https://www.youtube.com/watch?v=AZnGRKFUU0c

video on synchronous vs asynchronous vs multithreading vs multiprocessing https://www.youtube.com/watch?v=0vFgKr5bjWI

